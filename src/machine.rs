//! Multi-chip machine orchestrating all chips

use p3_field::Field;
use p3_matrix::dense::RowMajorMatrix;

use crate::chips::{CpuChip, MemoryChip, Poseidon2Chip, RangeCheckChip, Sha256Chip};
use crate::trace::ExecutionTrace;
use crate::F;

/// Multi-chip machine for ZK IR proving
pub struct ZkIrMachine {
    /// CPU chip for instruction execution
    pub cpu: CpuChip,
    /// Memory chip for consistency checking
    pub memory: MemoryChip,
    /// Range check chip for 32-bit validation
    pub range: RangeCheckChip,
    /// Poseidon2 chip for hash syscalls
    pub poseidon: Poseidon2Chip,
    /// SHA256 chip for hash syscalls
    pub sha256: Sha256Chip,
}

impl Default for ZkIrMachine {
    fn default() -> Self {
        Self::new()
    }
}

impl ZkIrMachine {
    /// Create a new machine with default configuration
    pub fn new() -> Self {
        Self {
            cpu: CpuChip,
            memory: MemoryChip,
            range: RangeCheckChip::default(),
            poseidon: Poseidon2Chip::default(),
            sha256: Sha256Chip::default(),
        }
    }

    /// Generate all chip traces from an execution trace
    pub fn generate_traces(&self, trace: &ExecutionTrace) -> MachineTraces<F> {
        // Generate individual chip traces
        let cpu_trace = self.cpu.generate_trace(trace);
        let memory_trace = self.memory.generate_trace(trace);

        // Collect all values that need range checking
        let range_values = self.collect_range_check_values(trace);
        let range_trace = self.range.generate_trace(&range_values);

        // Generate syscall traces
        let poseidon_trace = self.poseidon.generate_trace(&trace.syscalls);
        let sha256_trace = self.sha256.generate_trace(&trace.syscalls);

        MachineTraces {
            cpu: cpu_trace,
            memory: memory_trace,
            range: range_trace,
            poseidon: poseidon_trace,
            sha256: sha256_trace,
        }
    }

    /// Collect all values that need to be range-checked
    fn collect_range_check_values(&self, trace: &ExecutionTrace) -> Vec<u32> {
        let mut values = Vec::new();

        // Register values
        for step in &trace.steps {
            values.extend_from_slice(&step.registers);
        }

        // Memory values
        for access in &trace.memory_log {
            values.push(access.address);
            values.push(access.value);
        }

        // Remove duplicates for efficiency
        values.sort();
        values.dedup();
        values
    }

    /// Get information about this machine's chips
    pub fn chip_info(&self) -> Vec<ChipInfo> {
        vec![
            ChipInfo {
                name: "CPU",
                num_columns: 32,
                constraints_per_row: 48,
            },
            ChipInfo {
                name: "Memory",
                num_columns: 7,
                constraints_per_row: 10,
            },
            ChipInfo {
                name: "Range",
                num_columns: 6,
                constraints_per_row: 5,
            },
            ChipInfo {
                name: "Poseidon2",
                num_columns: 35,
                constraints_per_row: 200,
            },
            ChipInfo {
                name: "SHA256",
                num_columns: 20,
                constraints_per_row: 300, // per round, ~20k total per block
            },
        ]
    }
}

/// All traces generated by the machine
pub struct MachineTraces<F: Field> {
    pub cpu: RowMajorMatrix<F>,
    pub memory: RowMajorMatrix<F>,
    pub range: RowMajorMatrix<F>,
    pub poseidon: RowMajorMatrix<F>,
    pub sha256: RowMajorMatrix<F>,
}

/// Information about a chip
#[derive(Clone, Debug)]
pub struct ChipInfo {
    pub name: &'static str,
    pub num_columns: usize,
    pub constraints_per_row: usize,
}
